let t,e,s,i,r,n,h,l,a=!1;const m=[8,12,16,36,64],o=new Map([[8,0],[12,1],[16,2],[36,3],[64,4]]),u=new Map,_=new Map;let p=8;async function c({wasm:m="",simdWasm:o="",noSIMD:u=!1}={}){window.FinalizationRegistry&&(a=!0);try{t=await WebAssembly.instantiateStreaming(fetch(u?m:o)),console.info(u?"not using simd":"using simd")}catch(e){t=await WebAssembly.instantiateStreaming(fetch(m)),console.info("not using simd")}finally{e=t.instance.exports,s=e.memory,i=s.buffer,l=e.__heap_base.value,r=new Float32Array(i,e.getIn0Ptr(),16),n=new Float32Array(i,e.getIn1Ptr(),16),h=new Float32Array(i,e.getOutPtr(),16)}}function y(t){let e=0;const r=m.length;if(u.size){let s=o.get(t),i=u.get(m[s]);for(;s<r&&(!i||!i.length);)s++,i=u.get(m[s]);if(s!==r){const t=m[s];return e=u.get(t).pop(),_.set(e,t),e}}return l+t>i.byteLength&&(s.grow(p*=2),i=s.buffer),e=l,l+=t,_.set(e,t),e}function g(t){if(_.has(t)){const e=_.get(t);u.has(e)?u.get(e).push(t):u.set(e,[t]),_.delete(t)}}const x=new FinalizationRegistry((t=>{g(t)}));class w{constructor(){this.isMatrix4=!0,this.elements=new Float32Array(16),this.elements[0]=1,this.elements[5]=1,this.elements[10]=1,this.elements[15]=1}multiply(t){return e.matrix4_multiply(),this}premultiply(t){return r.set(t.elements,0),n.set(this.elements,0),e.matrix4_multiply(),this.elements.set(h,0),this}multiplyMatrices(t,s){return e.matrix4_multiply(),this}multiplyScalar(t){return r.set(this.elements,0),e.matrix4_multiply_scalar(t),this.elements.set(h,0),this}determinant(){return r.set(this.elements,0),e.matrix4_determinant()}transpose(){return r.set(this.elements,0),e.matrix4_transpose(),this.elements.set(h,0),this}invert(){return r.set(this.elements,0),e.matrix4_invert(),this.elements.set(h,0),this}invertTransform(){return r.set(this.elements,0),e.matrix4_invert_transform(),this.elements.set(h,0),this}scale(t){return this}lookAt(t,e,s){}equals(t){const e=this.elements,s=t.elements;for(let t=0;t<16;t++)if(e[t]!==s[t])return!1;return!0}set(t,e,s,i,r,n,h,l,a,m,o,u,_,p,c,y){const g=this.elements;return g[0]=t,g[4]=e,g[8]=s,g[12]=i,g[1]=r,g[5]=n,g[9]=h,g[13]=l,g[2]=a,g[6]=m,g[10]=o,g[14]=u,g[3]=_,g[7]=p,g[11]=c,g[15]=y,this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}setPosition(t,e,s){const i=this.elements;return i[12]=t,i[13]=e,i[14]=s,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new w).fromArray(this.elements)}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],e[9]=s[9],e[10]=s[10],e[11]=s[11],e[12]=s[12],e[13]=s[13],e[14]=s[14],e[15]=s[15],this}copyPosition(t){const e=this.elements,s=t.elements;return e[12]=s[12],e[13]=s[13],e[14]=s[14],this}fromArray(t,e=0){const s=this.elements;for(let i=0;i<16;i++)s[i]=t[i+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t[e+9]=s[9],t[e+10]=s[10],t[e+11]=s[11],t[e+12]=s[12],t[e+13]=s[13],t[e+14]=s[14],t[e+15]=s[15],t}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],s=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,s,i))}extractBasis(t,e,s){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(t,e,s){return this.set(t.x,e.x,s.x,0,t.y,e.y,s.y,0,t.z,e.z,s.z,0,0,0,0,1),this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,s=t.x,i=t.y,r=t.z,n=Math.cos(s),h=Math.sin(s),l=Math.cos(i),a=Math.sin(i),m=Math.cos(r),o=Math.sin(r);if("XYZ"===t.order){const t=n*m,s=n*o,i=h*m,r=h*o;e[0]=l*m,e[4]=-l*o,e[8]=a,e[1]=s+i*a,e[5]=t-r*a,e[9]=-h*l,e[2]=r-t*a,e[6]=i+s*a,e[10]=n*l}else if("YXZ"===t.order){const t=l*m,s=l*o,i=a*m,r=a*o;e[0]=t+r*h,e[4]=i*h-s,e[8]=n*a,e[1]=n*o,e[5]=n*m,e[9]=-h,e[2]=s*h-i,e[6]=r+t*h,e[10]=n*l}else if("ZXY"===t.order){const t=l*m,s=l*o,i=a*m,r=a*o;e[0]=t-r*h,e[4]=-n*o,e[8]=i+s*h,e[1]=s+i*h,e[5]=n*m,e[9]=r-t*h,e[2]=-n*a,e[6]=h,e[10]=n*l}else if("ZYX"===t.order){const t=n*m,s=n*o,i=h*m,r=h*o;e[0]=l*m,e[4]=i*a-s,e[8]=t*a+r,e[1]=l*o,e[5]=r*a+t,e[9]=s*a-i,e[2]=-a,e[6]=h*l,e[10]=n*l}else if("YZX"===t.order){const t=n*l,s=n*a,i=h*l,r=h*a;e[0]=l*m,e[4]=r-t*o,e[8]=i*o+s,e[1]=o,e[5]=n*m,e[9]=-h*m,e[2]=-a*m,e[6]=s*o+i,e[10]=t-r*o}else if("XZY"===t.order){const t=n*l,s=n*a,i=h*l,r=h*a;e[0]=l*m,e[4]=-o,e[8]=a*m,e[1]=t*o+r,e[5]=n*m,e[9]=s*o-i,e[2]=i*o-s,e[6]=h*m,e[10]=r*o+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){}makeTranslation(t,e,s){return this.set(1,0,0,t,0,1,0,e,0,0,1,s,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),s=Math.sin(t);return this.set(1,0,0,0,0,e,-s,0,0,s,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,0,s,0,0,1,0,0,-s,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,-s,0,0,s,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const s=Math.cos(e),i=Math.sin(e),r=1-s,n=t.x,h=t.y,l=t.z,a=r*n,m=r*h;return this.set(a*n+s,a*h-i*l,a*l+i*h,0,a*h+i*l,m*h+s,m*l-i*n,0,a*l-i*h,m*l+i*n,r*l*l+s,0,0,0,0,1),this}makeScale(t,e,s){return this.set(t,0,0,0,0,e,0,0,0,0,s,0,0,0,0,1),this}makeShear(t,e,s,i,r,n){return this.set(1,s,r,0,t,1,n,0,e,i,1,0,0,0,0,1),this}makePerspective(t,e,s,i,r,n){const h=this.elements,l=2*r/(e-t),a=2*r/(s-i),m=(e+t)/(e-t),o=(s+i)/(s-i),u=-(n+r)/(n-r),_=-2*n*r/(n-r);return h[0]=l,h[4]=0,h[8]=m,h[12]=0,h[1]=0,h[5]=a,h[9]=o,h[13]=0,h[2]=0,h[6]=0,h[10]=u,h[14]=_,h[3]=0,h[7]=0,h[11]=-1,h[15]=0,this}makeOrthographic(t,e,s,i,r,n){const h=this.elements,l=1/(e-t),a=1/(s-i),m=1/(n-r),o=(e+t)*l,u=(s+i)*a,_=(n+r)*m;return h[0]=2*l,h[4]=0,h[8]=0,h[12]=-o,h[1]=0,h[5]=2*a,h[9]=0,h[13]=-u,h[2]=0,h[6]=0,h[10]=-2*m,h[14]=-_,h[3]=0,h[7]=0,h[11]=0,h[15]=1,this}compose(t,e,s){const i=this.elements,r=e._x,n=e._y,h=e._z,l=e._w,a=r+r,m=n+n,o=h+h,u=r*a,_=r*m,p=r*o,c=n*m,y=n*o,g=h*o,x=l*a,w=l*m,f=l*o,F=s.x,d=s.y,A=s.z;return i[0]=(1-(c+g))*F,i[1]=(_+f)*F,i[2]=(p-w)*F,i[3]=0,i[4]=(_-f)*d,i[5]=(1-(u+g))*d,i[6]=(y+x)*d,i[7]=0,i[8]=(p+w)*A,i[9]=(y-x)*A,i[10]=(1-(u+c))*A,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,s){return this}}class f{__init(){this.isVector3=!0}constructor(t=0,e=0,s=0){f.prototype.__init.call(this),this.ptr=y(12),this._elements=new Float32Array(i,this.ptr,3),x.register(this,this.ptr),this._elements[0]=t,this._elements[1]=e,this._elements[2]=s}get x(){return this._elements.length||(this._elements=new Float32Array(i,this.ptr,3)),this._elements[0]}get y(){return this._elements.length||(this._elements=new Float32Array(i,this.ptr,3)),this._elements[1]}get z(){return this._elements.length||(this._elements=new Float32Array(i,this.ptr,3)),this._elements[2]}set x(t){this._elements.length||(this._elements=new Float32Array(i,this.ptr,3)),this._elements[0]=t}set y(t){this._elements.length||(this._elements=new Float32Array(i,this.ptr,3)),this._elements[1]=t}set z(t){this._elements.length||(this._elements=new Float32Array(i,this.ptr,3)),this._elements[2]=t}dispose(){x.unregister(this),g(this.ptr)}}class F{__init(){this.isVector3=!0}constructor(t=0,e=0,s=0,r=1){F.prototype.__init.call(this),this.ptr=y(16),this._elements=new Float32Array(i,this.ptr,4),x.register(this,this.ptr),this._elements[0]=t,this._elements[1]=e,this._elements[2]=s,this._elements[3]=s}get x(){return this._elements.length||(this._elements=new Float32Array(i,this.ptr,4)),this._elements[0]}get y(){return this._elements.length||(this._elements=new Float32Array(i,this.ptr,4)),this._elements[1]}get z(){return this._elements.length||(this._elements=new Float32Array(i,this.ptr,4)),this._elements[2]}get w(){return this._elements.length||(this._elements=new Float32Array(i,this.ptr,4)),this._elements[3]}set x(t){this._elements.length||(this._elements=new Float32Array(i,this.ptr,4)),this._elements[0]=t}set y(t){this._elements.length||(this._elements=new Float32Array(i,this.ptr,4)),this._elements[1]=t}set z(t){this._elements.length||(this._elements=new Float32Array(i,this.ptr,4)),this._elements[2]=t}set w(t){this._elements.length||(this._elements=new Float32Array(i,this.ptr,4)),this._elements[3]=t}dispose(){x.unregister(this),g(this.ptr)}}function d(t){class s extends t{__init(){this._disposed=!1}constructor(){super(),s.prototype.__init.call(this),this.ptr=y(64),this._elements=new Float32Array(i,this.ptr,16),this.identity(),x.register(this,this.ptr)}multiply(t){return e.matrix4_multiply(this.ptr,t.ptr,this.ptr),this}multiply(t){return e.matrix4_multiply(this.ptr,t.ptr,this.ptr),this}premultiply(t){return e.matrix4_multiply(t.ptr,this.ptr,this.ptr),this}multiplyMatrices(t,s){return e.matrix4_multiply(t.ptr,s.ptr,this.ptr),this}multiplyScalar(t){return e.matrix4_multiply_scalar(this.ptr,t),this}determinant(){return e.matrix4_determinant(this.ptr)}transpose(){return e.matrix4_transpose(this.ptr),this}invert(){return e.matrix4_invert(this.ptr),this}invertTransform(){return e.matrix4_invert_transform(this.ptr),this}get elements(){return this._elements.length||(this._elements=new Float32Array(i,this.ptr,16)),this._elements}set elements(t){if(this._elements){this._elements.length||(this._elements=new Float32Array(i,this.ptr,16));for(let e=Math.min(t.length,16),s=0;s<e;s++)this._elements[s]=t[s]}}dispose(){this._disposed||(x.unregister(this),g(this.ptr),this._disposed=!0)}}return s}export{w as Matrix4,f as Vector3,F as Vector4,d as convertTHREEMatrix4,g as free,c as init,t as instanceSource,y as malloc,r as matrix4In0View,n as matrix4In1View,h as matrix4OutView,a as storeDataInWasm,e as wasmExports,s as wasmMemory,i as wasmMemoryBuffer,x as wasmRegistry};
