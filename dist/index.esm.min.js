let t,e,s,r,i,n=!1;const a=[8,12,16,36,64],h=new Map([[8,0],[12,1],[16,2],[36,3],[64,4]]),l=new Map,o=new Map;let m=8;async function p({wasm:a="",simdWasm:h=""}={}){window.FinalizationRegistry&&(n=!0);try{t=await WebAssembly.instantiateStreaming(fetch(h)),console.info("using simd")}catch(e){t=await WebAssembly.instantiateStreaming(fetch(a)),console.info("using none simd")}finally{e=t.instance.exports,s=e.memory,r=s.buffer,i=e.__heap_base.value}}function u(t){let e=0;const n=a.length;if(l.size){let s=h.get(t),r=l.get(a[s]);for(;s<n&&(!r||!r.length);)s++,r=l.get(a[s]);if(s!==n){const t=a[s];return e=l.get(t).pop(),o.set(e,t),e}}return i+t>s.buffer.byteLength&&(s.grow(m*=2),r=s.buffer),e=i,i+=t,o.set(e,t),e}function c(t){if(o.has(t)){const e=o.get(t);l.has(e)?l.get(e).push(t):l.set(e,[t]),o.delete(t)}}const f=new FinalizationRegistry((t=>{c(t)}));class y{constructor(){this.ptr=u(64),this._elements=new Float32Array(r,this.ptr,16),this.identity(),f.register(this,this.ptr)}multiply(t){return e.matrix4_multiply(this.ptr,t.ptr,this.ptr),this}premultiply(t){return e.matrix4_multiply(t.ptr,this.ptr,this.ptr),this}multiplyMatrices(t,s){return e.matrix4_multiply(t.ptr,s.ptr,this.ptr),this}determinant(){return e.matrix4_determinant(this.ptr)}transpose(){return e.matrix4_transpose(this.ptr),this}invert(){return e.matrix4_invert(this.ptr),this}invertTransform(){return e.matrix4_invert_transform(this.ptr),this}get elements(){return this._elements.length||(this._elements=new Float32Array(r,this.ptr,16)),this._elements}set(t,e,s,r,i,n,a,h,l,o,m,p,u,c,f,y){const g=this.elements;return g[0]=t,g[4]=e,g[8]=s,g[12]=r,g[1]=i,g[5]=n,g[9]=a,g[13]=h,g[2]=l,g[6]=o,g[10]=m,g[14]=p,g[3]=u,g[7]=c,g[11]=f,g[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new y).fromArray(this.elements)}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],e[9]=s[9],e[10]=s[10],e[11]=s[11],e[12]=s[12],e[13]=s[13],e[14]=s[14],e[15]=s[15],this}copyPosition(t){const e=this.elements,s=t.elements;return e[12]=s[12],e[13]=s[13],e[14]=s[14],this}fromArray(t,e=0){const s=this.elements;for(let r=0;r<16;r++)s[r]=t[r+e];return this}dispose(){f.unregister(this),c(this.ptr)}}export{y as Matrix4,c as free,p as init,t as instanceSource,u as malloc,n as storeDataInWasm,e as wasmExports,s as wasmMemory,r as wasmMemoryBuffer,f as wasmRegistry};
