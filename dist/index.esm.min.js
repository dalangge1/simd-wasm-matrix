let t,e,s,i,r,n=!1;const h=[8,12,16,36,64],a=new Map([[8,0],[12,1],[16,2],[36,3],[64,4]]),o=new Map,m=new Map;let l=8;async function u({wasm:h="",simdWasm:a="",noSIMD:o=!1}={}){window.FinalizationRegistry&&(n=!0);try{t=await WebAssembly.instantiateStreaming(fetch(o?h:a)),console.info(o?"not using simd":"using simd")}catch(e){t=await WebAssembly.instantiateStreaming(fetch(h)),console.info("not using simd")}finally{e=t.instance.exports,s=e.memory,i=s.buffer,r=e.__heap_base.value}}function c(t){let e=0;const n=h.length;if(o.size){let s=a.get(t),i=o.get(h[s]);for(;s<n&&(!i||!i.length);)s++,i=o.get(h[s]);if(s!==n){const t=h[s];return e=o.get(t).pop(),m.set(e,t),e}}return r+t>i.byteLength&&(s.grow(l*=2),i=s.buffer),e=r,r+=t,m.set(e,t),e}function p(t){if(m.has(t)){const e=m.get(t);o.has(e)?o.get(e).push(t):o.set(e,[t]),m.delete(t)}}const y=new FinalizationRegistry((t=>{p(t)}));class x{constructor(){this.ptr=c(64),this._elements=new Float32Array(i,this.ptr,16),this.identity(),y.register(this,this.ptr)}multiply(t){return e.matrix4_multiply(this.ptr,t.ptr,this.ptr),this}premultiply(t){return e.matrix4_multiply(t.ptr,this.ptr,this.ptr),this}multiplyMatrices(t,s){return e.matrix4_multiply(t.ptr,s.ptr,this.ptr),this}multiplyScalar(t){return e.matrix4_multiply_scalar(this.ptr,t),this}determinant(){return e.matrix4_determinant(this.ptr)}transpose(){return e.matrix4_transpose(this.ptr),this}invert(){return e.matrix4_invert(this.ptr),this}invertTransform(){return e.matrix4_invert_transform(this.ptr),this}scale(t){const e=this.elements,s=t.x,i=t.y,r=t.z;return e[0]*=s,e[4]*=i,e[8]*=r,e[1]*=s,e[5]*=i,e[9]*=r,e[2]*=s,e[6]*=i,e[10]*=r,e[3]*=s,e[7]*=i,e[11]*=r,this}setPosition(t,e,s){const i=this.elements;return i[12]=t,i[13]=e,i[14]=s,this}get elements(){return this._elements.length||(this._elements=new Float32Array(i,this.ptr,16)),this._elements}set(t,e,s,i,r,n,h,a,o,m,l,u,c,p,y,x){const g=this.elements;return g[0]=t,g[4]=e,g[8]=s,g[12]=i,g[1]=r,g[5]=n,g[9]=h,g[13]=a,g[2]=o,g[6]=m,g[10]=l,g[14]=u,g[3]=c,g[7]=p,g[11]=y,g[15]=x,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new x).fromArray(this.elements)}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],e[9]=s[9],e[10]=s[10],e[11]=s[11],e[12]=s[12],e[13]=s[13],e[14]=s[14],e[15]=s[15],this}copyPosition(t){const e=this.elements,s=t.elements;return e[12]=s[12],e[13]=s[13],e[14]=s[14],this}fromArray(t,e=0){const s=this.elements;for(let i=0;i<16;i++)s[i]=t[i+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t[e+9]=s[9],t[e+10]=s[10],t[e+11]=s[11],t[e+12]=s[12],t[e+13]=s[13],t[e+14]=s[14],t[e+15]=s[15],t}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,s){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(t,e,s){return this.set(t.x,e.x,s.x,0,t.y,e.y,s.y,0,t.z,e.z,s.z,0,0,0,0,1),this}makeTranslation(t,e,s){return this.set(1,0,0,t,0,1,0,e,0,0,1,s,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),s=Math.sin(t);return this.set(1,0,0,0,0,e,-s,0,0,s,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,0,s,0,0,1,0,0,-s,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,-s,0,0,s,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const s=Math.cos(e),i=Math.sin(e),r=1-s,n=t.x,h=t.y,a=t.z,o=r*n,m=r*h;return this.set(o*n+s,o*h-i*a,o*a+i*h,0,o*h+i*a,m*h+s,m*a-i*n,0,o*a-i*h,m*a+i*n,r*a*a+s,0,0,0,0,1),this}makeScale(t,e,s){return this.set(t,0,0,0,0,e,0,0,0,0,s,0,0,0,0,1),this}makeShear(t,e,s,i,r,n){return this.set(1,s,r,0,t,1,n,0,e,i,1,0,0,0,0,1),this}makePerspective(t,e,s,i,r,n){const h=this.elements,a=2*r/(e-t),o=2*r/(s-i),m=(e+t)/(e-t),l=(s+i)/(s-i),u=-(n+r)/(n-r),c=-2*n*r/(n-r);return h[0]=a,h[4]=0,h[8]=m,h[12]=0,h[1]=0,h[5]=o,h[9]=l,h[13]=0,h[2]=0,h[6]=0,h[10]=u,h[14]=c,h[3]=0,h[7]=0,h[11]=-1,h[15]=0,this}makeOrthographic(t,e,s,i,r,n){const h=this.elements,a=1/(e-t),o=1/(s-i),m=1/(n-r),l=(e+t)*a,u=(s+i)*o,c=(n+r)*m;return h[0]=2*a,h[4]=0,h[8]=0,h[12]=-l,h[1]=0,h[5]=2*o,h[9]=0,h[13]=-u,h[2]=0,h[6]=0,h[10]=-2*m,h[14]=-c,h[3]=0,h[7]=0,h[11]=0,h[15]=1,this}compose(t,e,s){const i=this.elements,r=e._x,n=e._y,h=e._z,a=e._w,o=r+r,m=n+n,l=h+h,u=r*o,c=r*m,p=r*l,y=n*m,x=n*l,g=h*l,f=a*o,_=a*m,M=a*l,w=s.x,d=s.y,z=s.z;return i[0]=(1-(y+g))*w,i[1]=(c+M)*w,i[2]=(p-_)*w,i[3]=0,i[4]=(c-M)*d,i[5]=(1-(u+g))*d,i[6]=(x+f)*d,i[7]=0,i[8]=(p+_)*z,i[9]=(x-f)*z,i[10]=(1-(u+y))*z,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,e,s){return this}dispose(){y.unregister(this),p(this.ptr)}}export{x as Matrix4,p as free,u as init,t as instanceSource,c as malloc,n as storeDataInWasm,e as wasmExports,s as wasmMemory,i as wasmMemoryBuffer,y as wasmRegistry};
